# 互斥同步

### 互斥

保证一个线程在临界区执行时，其他线程应该被阻止进入临界区

「操作 A 和操作 B 不能在同一时刻执行」

### 同步 

并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。

「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」

# 互斥与同步的实现和使用

两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。

### 锁：加锁、解锁操作

加锁操作和解锁操作可以解决并发线程/进程的互斥问题

任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。

### 信号量：P、V 操作

信号量是操作系统提供的一种协调共享资源访问的方法。

P 操作是用在进入临界区之前，V 操作是用在离开临界区之后，这两个操作是必须成对出现的。

# 生产者-消费者问题

![](image/屏幕截图_20250722_192329.png)

- `生产者`在生成数据后，放在一个缓冲区中；
- `消费者`从缓冲区取出数据处理；
- 任何时刻，只能有一个生产者或消费者可以访问缓冲区；

# 锁

### 死锁

`死锁` : 两个线程都在等待对方释放锁

死锁条件:

- 1.互斥条件；

    指多个线程不能同时使用同一个资源。
- 2.持有并等待条件；

    指当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C持有了，所以线程 A 就会处于等待状态，但是线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。
- 3.不可剥夺条件；

    指当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。
- 4.环路等待条件；

    指在死锁发生的时候，两个线程获取资源的顺序构成了环形链。

避免死锁:

使用资源有序分配法，来破环环路等待条件

### 互斥锁与自旋锁

- 互斥锁加锁失败后，线程会释放 CPU ，给其他线程；
- 自旋锁加锁失败后，线程会忙等待，直到它拿到锁；

### 读写锁

读写锁适用于能明确区分读操作和写操作的场景。写锁是独占锁，读锁是共享锁。读写锁在读多写少的场景，能发挥出优势。

工作原理：

- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。

- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。

### 乐观锁与悲观锁

前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。

`悲观锁`认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。

`乐观锁`全程并没有加锁，所以它也叫无锁编程。(在线文档)

只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁
