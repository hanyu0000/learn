# DMA技术(直接内存访问)

在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，数据搬运的工作全部交给 DMA 控制器，这样 CPU 就可以去处理别的事务。

具体过程：

- 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；
- 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；
- DMA 进一步将 I/O 请求发送给磁盘；
- 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；
- DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；
- 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；
- CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；

CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成

### 如何优化文件传输的性能?

减少用户态与内核态的上下文切换的次数，即减少系统调用的次数

减少数据拷贝的次数：用户的缓冲区没有必要存在

# 零拷贝

全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。零拷贝技术可以把文件传输的性能提高至少一倍以上。

零拷贝技术只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。

### mmap + write

```c
buf = mmap(file, len);
write(sockfd, buf, len);
```
read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数

mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作

通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程， 仍然需要 4 次上下文切换，因为系统调用还是 2 次

### sendfile

```c
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销，
就只有 2 次上下文切换，和 3 次数据拷贝。

# PageCache (磁盘高速缓存)

优点：
- 缓存最近被访问的数据
- 预读功能
  
零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能。用 PageCache 来缓存最近被访问的数据，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。

但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能

# 大文件传输

在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术。

读操作分为两部分：

- 内核向磁盘发起读请求，但是可以不等待数据就位就可以返回，于是进程此时可以处理其他任务；
- 内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的通知，再去处理数据；
